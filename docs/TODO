DOING

TODO

- gestionar errores en las llamadas al sistema

- add goto CGI confirmation (find .py or .go)

- reflexionar sobre almacenamiento (particularmente imagenes y videos) en deques, porque gestiona la memoria en bloques de 512

- en el mac hay un buffer de 10000 caracteres por socket al que le puedes escribir por cada socket, si quieres escribir mas tienes que hacer mas de un send

- probablemente lo primero que haya que hacer cuando lancemos el fork sea matar TODOS los fds (para no tener el mismo fd escuchando en dos procesos), pensar en ello

- para respuestas de entorno a 5*10^6 caracteres el send no da error, pero salta pollerr, se manda bastante parte del mensaje pero no todo, hay que ver como fragmentamos archivos grandes

CONCLUSIONES

+ tanto GET como DELETE, si me metes body la chupas, va para la proxima request

- reflexionar sobre de cuanto en cuanto leo, y como gestionar la data extra en las conexiones
+ Gestionarlo leyendo de x en x, el metodo addData de la request devuelve la data que no ha usado y la data\
  por parsear se guarda en la conexion

- reflexionar sobre como checkear el maxbody size del server, idealmente saberlo antes de parsear el body, asi podremos\
  cortar en cuanto veamos que nos pasan un body length mas grande que el que queramos recibir en vez de parsear todo.
+ No tiene sentido hacerlo ya que solo valdria para una proteccion contra DDOS, pero podria haber otras muchas formas en\
  las que nos pueden hacer DDOS.

- reflexionar sobre que pasa cuando el Host es una ip o localhost en vez de un regname, a que server lo mando?? 
+ Lo mando al default, si hay un servidor con nombre localhost pues lo mando al localhost

+ wether the method used is valid should be checked in the Response creation (as it depends on locations, not ports)

- reflexionar sobre la coincidencia de un path de una location, si tengo un servidor con locations definidas de esta forma:
                            location /kk2/kk {
                              root /root/; 
                            }
                            location /kk2/ {
                              root /root2/; 
                            }

  Como es el curso de accion cuando una request con este path llega "/kk/kk2/app.py". Lo que ocurre es que vas desglosando por '/' de tal forma que confirmas primero "/kk2/kk" y tienes una coincidencia, lo que ocurre es que al revisar "/root/app".py en tu local encuentras que no es accesible. Aqui hay dos cursos de accion, el primero seria devolver un 404 y ya esta, otra seria continuar desglosando por '/' de forma que confirmarias "/kk2" en el path y obtendrias una nueva coincidencia. Bajo esta coincidencia la confirmacion de acceso seria "/root2/app.py" y al revisar resulta que si tienes acceso. CONCLUSION: Nginx hace por defecto el primer approach pero esto es asi ya que tiene una regla exacta para esta interactuacion.

- reflexionar si en el parseo una vez un root es encontrado ha de ser confirmado el acceso

- refelexionar si el cgi admite cualquier tipo de request (GET; POST; DELETE)
